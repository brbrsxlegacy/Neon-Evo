<!DOCTYPE html>
<html lang="tr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<title>NEON RISE ONLINE</title>

<style>
html,body{
  margin:0;
  padding:0;
  overflow:hidden;
  background:#05060a;
  font-family:system-ui;
}
canvas{
  display:block;
  background:radial-gradient(circle at center,#0b1020,#02030a);
}
.ui-btn{
  position:fixed;
  padding:6px 10px;
  background:#0ff2;
  color:#eaf2ff;
  border:1px solid #0ff;
  cursor:pointer;
}
</style>
</head>
<body>

<canvas id="game"></canvas>

<script type="module">

/* ===============================
   FIREBASE INIT (MODERN v10)
================================= */

import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-app.js";
import { 
  getDatabase, ref, set, onValue, push,
  remove, onDisconnect, get
} from "https://www.gstatic.com/firebasejs/10.12.0/firebase-database.js";

const firebaseConfig = {
  apiKey: "BURAYA_API",
  authDomain: "BURAYA_AUTH",
  databaseURL: "BURAYA_DB_URL",
  projectId: "BURAYA_ID",
  storageBucket: "BURAYA_STORAGE",
  messagingSenderId: "BURAYA_MSG",
  appId: "BURAYA_APP"
};

const app = initializeApp(firebaseConfig);
const db = getDatabase(app);

/* ===============================
   CORE ENGINE
================================= */

const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

function resize(){
  canvas.width = innerWidth;
  canvas.height = innerHeight;
}
resize();
addEventListener("resize",resize);

let last = 0;
function loop(t){
  const dt = (t-last)/1000;
  last = t;

  if(game.state==="play"){
    update(dt);
    draw();
  }

  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

/* ===============================
   GAME STATE MACHINE
================================= */

const game = {
  state:"menu"
};

/* ===============================
   INPUT
================================= */

const keys = {};
addEventListener("keydown",e=>keys[e.key]=true);
addEventListener("keyup",e=>keys[e.key]=false);

/* ===============================
   PLAYER CLASS
================================= */

class Player{
  constructor(){
    this.x=0;
    this.y=0;
    this.size=18;
    this.speed=260;

    this.maxHp=100;
    this.hp=100;

    this.level=1;
    this.xp=0;
    this.xpNext=100;

    this.coins=0;

    this.rank="BRONZE";
  }

  update(dt){
    let dx=0,dy=0;

    if(keys["w"]||keys["ArrowUp"]) dy--;
    if(keys["s"]||keys["ArrowDown"]) dy++;
    if(keys["a"]||keys["ArrowLeft"]) dx--;
    if(keys["d"]||keys["ArrowRight"]) dx++;

    const len=Math.hypot(dx,dy);
    if(len){
      dx/=len; dy/=len;
      this.x+=dx*this.speed*dt;
      this.y+=dy*this.speed*dt;
    }
  }

  draw(){
    ctx.save();
    ctx.translate(canvas.width/2,canvas.height/2);

    ctx.shadowBlur=25;
    ctx.shadowColor="#00ffff";
    ctx.fillStyle="#00ffff";
    ctx.beginPath();
    ctx.arc(0,0,this.size,0,Math.PI*2);
    ctx.fill();

    ctx.restore();
  }

  addXP(v){
    this.xp+=v;
    if(this.xp>=this.xpNext){
      this.level++;
      this.xp=0;
      this.xpNext=Math.floor(this.xpNext*1.3);
      this.speed+=10;
      this.maxHp+=10;
      this.hp=this.maxHp;
      updateRank();
    }
  }
}

const player = new Player();

/* ===============================
   ENEMY SYSTEM
================================= */

class Enemy{
  constructor(x,y){
    this.x=x;
    this.y=y;
    this.size=16;
    this.speed=120;
    this.hp=40;
  }

  update(dt){
    const dx=player.x-this.x;
    const dy=player.y-this.y;
    const d=Math.hypot(dx,dy);
    this.x+=(dx/d)*this.speed*dt;
    this.y+=(dy/d)*this.speed*dt;

    if(d < this.size+player.size){
      player.hp-=10;
    }
  }

  draw(){
    ctx.beginPath();
    ctx.fillStyle="#ff3355";
    ctx.arc(
      this.x-player.x+canvas.width/2,
      this.y-player.y+canvas.height/2,
      this.size,0,Math.PI*2);
    ctx.fill();
  }
}

const enemies=[];

function spawnEnemy(){
  const a=Math.random()*Math.PI*2;
  const d=500;
  enemies.push(new Enemy(
    player.x+Math.cos(a)*d,
    player.y+Math.sin(a)*d
  ));
}

setInterval(()=>{
  if(game.state==="play") spawnEnemy();
},2000);

rewardCoins(10);

/* ===============================
   MULTIPLAYER ROOM
================================= */

let roomName=null;
let myRef=null;
let myId=localStorage.getItem("nr_id") || 
         "p_"+Math.random().toString(36).substr(2,9);

localStorage.setItem("nr_id",myId);

const remotePlayers={};

async function createRoom(){
  roomName="room_"+Math.random().toString(36).substr(2,5);

  await set(ref(db,"rooms/"+roomName+"/meta"),{
    respawn:{x:0,y:0}
  });

  joinRoom(roomName);
}

async function joinRoom(name){

  if(myRef) remove(myRef);

  roomName=name;

  myRef=ref(db,"rooms/"+roomName+"/players/"+myId);

  await set(myRef,{
    x:player.x,
    y:player.y,
    level:player.level
  });

  onDisconnect(myRef).remove();

  setInterval(()=>{
    if(!roomName) return;
    set(myRef,{
      x:player.x,
      y:player.y,
      level:player.level
    });
  },100);

  onValue(ref(db,"rooms/"+roomName+"/players"),snap=>{
    const data=snap.val()||{};
    Object.keys(remotePlayers).forEach(k=>delete remotePlayers[k]);
    Object.entries(data).forEach(([id,p])=>{
      if(id===myId) return;
      remotePlayers[id]=p;
    });
  });
}
attachChat();
/* ===============================
   UPDATE & DRAW
================================= */

function update(dt){
  player.update(dt);
  enemies.forEach(e=>e.update(dt));
const _baseUpdate=update;
update=function(dt){
  _baseUpdate(dt);
  updateCombat(dt);
  updateParticles(dt);
  checkAchievements();
};

  for(let i=enemies.length-1;i>=0;i--){
    if(enemies[i].hp<=0){
      player.addXP(20);
      enemies.splice(i,1);
    }
  }

  if(player.hp<=0){
    game.state="menu";
  }
}

function draw(){

  ctx.clearRect(0,0,canvas.width,canvas.height);

  // grid
  ctx.strokeStyle="rgba(0,255,255,0.05)";
  for(let x=-2000;x<2000;x+=60){
    ctx.beginPath();
    ctx.moveTo(
      x-player.x+canvas.width/2,
      -2000-player.y+canvas.height/2);
    ctx.lineTo(
      x-player.x+canvas.width/2,
      2000-player.y+canvas.height/2);
    ctx.stroke();
  }

  enemies.forEach(e=>e.draw());

  // remote players
  Object.values(remotePlayers).forEach(p=>{
    ctx.beginPath();
    ctx.fillStyle="#ff00ff";
    ctx.arc(
      p.x-player.x+canvas.width/2,
      p.y-player.y+canvas.height/2,
      16,0,Math.PI*2);
    ctx.fill();
  });

  player.draw();
}
const _baseDraw=draw;
draw=function(){
  _baseDraw();
  drawParticles();
};
const _drawSkin = draw;
draw = function(){
  _drawSkin();

  ctx.save();
  ctx.translate(canvas.width/2,canvas.height/2);

  ctx.shadowBlur=25;
  ctx.shadowColor=player.skin;
  ctx.fillStyle=player.skin;

  ctx.beginPath();
  ctx.arc(0,0,player.size,0,Math.PI*2);
  ctx.fill();

  ctx.restore();
};


/* ===============================
   RANK SYSTEM
================================= */

function updateRank(){
  if(player.level>=50) player.rank="DIAMOND";
  else if(player.level>=25) player.rank="GOLD";
  else if(player.level>=10) player.rank="SILVER";
  else player.rank="BRONZE";
}

/* ===============================
   MENU UI
================================= */

const menu=document.createElement("div");
menu.style.cssText=`
position:fixed;
inset:0;
background:#000;
color:#0ff;
display:flex;
flex-direction:column;
align-items:center;
justify-content:center;
`;
menu.innerHTML=`
<h1>NEON RISE ONLINE</h1>
<button id="createBtn">ODA OLUŞTUR</button>
<button id="joinBtn">ODA BUL</button>
`;
document.body.appendChild(menu);

document.getElementById("createBtn").onclick=()=>{
  createRoom();
  menu.style.display="none";
  game.state="play";
};

document.getElementById("joinBtn").onclick=async()=>{
  const snap=await get(ref(db,"rooms"));
  const rooms=snap.val()||{};
  for(const r in rooms){
    joinRoom(r);
    menu.style.display="none";
    game.state="play";
    return;
  }
  alert("Oda yok.");
};
/* ===============================
   COMBAT SYSTEM
================================= */

const bullets = [];
const attack = {
  meleeCD:0,
  rangedCD:0
};

addEventListener("keydown",e=>{
  if(e.code==="Space") tryMelee();
  if(e.key==="f"||e.key==="F") tryShoot();
});

function tryMelee(){
  if(attack.meleeCD>0) return;
  attack.meleeCD=0.4;

  enemies.forEach(e=>{
    const d=Math.hypot(e.x-player.x,e.y-player.y);
    if(d<50){
      e.hp-=25;
      spawnParticles(e.x,e.y,"#ff3355",12);
    }
  });

  Object.entries(remotePlayers).forEach(([id,p])=>{
    const d=Math.hypot(p.x-player.x,p.y-player.y);
    if(d<50){
      damageRemote(id,20);
    }
  });
}

function tryShoot(){
  if(attack.rangedCD>0) return;
  attack.rangedCD=0.25;

  bullets.push({
    x:player.x,
    y:player.y,
    vx:400,
    vy:0
  });
}

function updateCombat(dt){
  if(attack.meleeCD>0) attack.meleeCD-=dt;
  if(attack.rangedCD>0) attack.rangedCD-=dt;

  for(let i=bullets.length-1;i>=0;i--){
    const b=bullets[i];
    b.x+=b.vx*dt;
    b.y+=b.vy*dt;

    enemies.forEach(e=>{
      if(Math.hypot(e.x-b.x,e.y-b.y)<20){
        e.hp-=20;
        spawnParticles(e.x,e.y,"#ffaa00",8);
      }
    });

    if(Math.hypot(b.x-player.x,b.y-player.y)>800){
      bullets.splice(i,1);
    }
  }
}
const particles=[];

function spawnParticles(x,y,color,count){
  for(let i=0;i<count;i++){
    particles.push({
      x,y,
      vx:(Math.random()-0.5)*300,
      vy:(Math.random()-0.5)*300,
      life:0.6,
      color
    });
  }
}

function updateParticles(dt){
  for(let i=particles.length-1;i>=0;i--){
    const p=particles[i];
    p.life-=dt;
    p.x+=p.vx*dt;
    p.y+=p.vy*dt;
    if(p.life<=0) particles.splice(i,1);
  }
}

function drawParticles(){
  particles.forEach(p=>{
    ctx.globalAlpha=p.life;
    ctx.fillStyle=p.color;
    ctx.beginPath();
    ctx.arc(
      p.x-player.x+canvas.width/2,
      p.y-player.y+canvas.height/2,
      3,0,Math.PI*2);
    ctx.fill();
  });
  ctx.globalAlpha=1;
}
class Boss extends Enemy{
  constructor(x,y){
    super(x,y);
    this.size=40;
    this.hp=600;
    this.speed=70;
  }

  update(dt){
    super.update(dt);

    if(Math.random()<0.01){
      spawnEnemy();
    }
  }

  draw(){
    ctx.beginPath();
    ctx.fillStyle="#ff00ff";
    ctx.arc(
      this.x-player.x+canvas.width/2,
      this.y-player.y+canvas.height/2,
      this.size,0,Math.PI*2);
    ctx.fill();
  }
}

function spawnBoss(){
  enemies.push(new Boss(player.x+400,player.y));
}

setInterval(()=>{
  if(player.level>=10 && game.state==="play"){
    spawnBoss();
  }
},20000);
player.inventory=[];
player.coins=0;

function rewardCoins(v){
  player.coins+=v;
}

const shopBtn=document.createElement("button");
shopBtn.textContent="SHOP";
shopBtn.className="ui-btn";
shopBtn.style.top="10px";
shopBtn.style.right="10px";
document.body.appendChild(shopBtn);

const shopPanel=document.createElement("div");
shopPanel.style.cssText=`
position:fixed;
inset:20%;
background:#000;
color:#0ff;
border:2px solid #0ff;
padding:20px;
display:none;
`;
document.body.appendChild(shopPanel);

shopBtn.onclick=()=>{
  shopPanel.style.display=
    shopPanel.style.display==="none"?"block":"none";
  renderShop();
};

function renderShop(){
  shopPanel.innerHTML="<h2>SHOP</h2>";
  const item=document.createElement("button");
  item.textContent="Aura Boost (200)";
  item.onclick=()=>{
    if(player.coins>=200){
      player.coins-=200;
      player.speed+=20;
    }
  };
  shopPanel.appendChild(item);
}
setInterval(()=>{
  if(!roomName) return;
  set(ref(db,"leaderboard/"+myId),{
    level:player.level,
    coins:player.coins
  });
},15000);

const lb=document.createElement("div");
lb.style.cssText=`
position:fixed;
left:10px;
top:80px;
color:#0ff;
font-size:12px;
`;
document.body.appendChild(lb);

onValue(ref(db,"leaderboard"),snap=>{
  const data=snap.val()||{};
  const arr=Object.entries(data)
    .sort((a,b)=>b[1].level-a[1].level)
    .slice(0,5);

  lb.innerHTML="<b>TOP 5</b><br>";
  arr.forEach((p,i)=>{
    lb.innerHTML+=`${i+1}. ${p[0]} Lv${p[1].level}<br>`;
  });
});
const chat=document.createElement("input");
chat.placeholder="Mesaj...";
chat.style.position="fixed";
chat.style.bottom="10px";
chat.style.right="10px";
document.body.appendChild(chat);

chat.addEventListener("keydown",e=>{
  if(e.key==="Enter" && roomName){
    push(ref(db,"rooms/"+roomName+"/chat"),{
      user:myId,
      msg:chat.value
    });
    chat.value="";
  }
});

const chatBox=document.createElement("div");
chatBox.style.cssText=`
position:fixed;
bottom:40px;
right:10px;
width:200px;
height:120px;
overflow:auto;
font-size:12px;
color:#0ff;
`;
document.body.appendChild(chatBox);

function attachChat(){
  onValue(ref(db,"rooms/"+roomName+"/chat"),snap=>{
    const data=snap.val()||{};
    chatBox.innerHTML="";
    Object.values(data).slice(-10).forEach(m=>{
      chatBox.innerHTML+=
        `<div><b>${m.user}:</b> ${m.msg}</div>`;
    });
  });
}
/* ===============================
   CLAN SYSTEM
================================= */

player.clan = null;

const clanBtn = document.createElement("button");
clanBtn.textContent = "CLAN";
clanBtn.className = "ui-btn";
clanBtn.style.top = "50px";
clanBtn.style.right = "10px";
document.body.appendChild(clanBtn);

const clanPanel = document.createElement("div");
clanPanel.style.cssText = `
position:fixed;
inset:25%;
background:#000;
color:#0ff;
border:2px solid #0ff;
padding:20px;
display:none;
`;
document.body.appendChild(clanPanel);

clanBtn.onclick = ()=>{
  clanPanel.style.display =
    clanPanel.style.display==="none"?"block":"none";
  renderClan();
};

function renderClan(){
  clanPanel.innerHTML = `
  <h2>CLAN</h2>
  <input id="clanName" placeholder="Clan adı">
  <button id="createClan">Oluştur</button>
  <button id="joinClan">Katıl</button>
  <hr>
  Mevcut Clan: ${player.clan || "Yok"}
  `;

  document.getElementById("createClan").onclick = async ()=>{
    const name = document.getElementById("clanName").value;
    if(!name) return;

    await set(ref(db,"clans/"+name+"/members/"+myId),true);
    player.clan = name;
    renderClan();
  };

  document.getElementById("joinClan").onclick = async ()=>{
    const name = document.getElementById("clanName").value;
    if(!name) return;

    const snap = await get(ref(db,"clans/"+name));
    if(!snap.exists()){
      alert("Clan yok");
      return;
    }

    await set(ref(db,"clans/"+name+"/members/"+myId),true);
    player.clan = name;
    renderClan();
  };
}
/* ===============================
   SKIN SYSTEM
================================= */

player.skin = "#00ffff";
player.inventory = [];

function dropSkin(){
  const color = `hsl(${Math.random()*360},80%,60%)`;
  player.inventory.push(color);
}

function openWardrobe(){
  const w = document.createElement("div");
  w.style.cssText = `
  position:fixed;
  inset:30%;
  background:#000;
  border:2px solid #0ff;
  color:#0ff;
  overflow:auto;
  `;
  w.innerHTML="<h3>DOLAP</h3>";

  player.inventory.forEach(s=>{
    const b=document.createElement("button");
    b.textContent=s;
    b.style.background=s;
    b.onclick=()=>{
      player.skin=s;
    };
    w.appendChild(b);
  });

  document.body.appendChild(w);
}

const wardrobeBtn=document.createElement("button");
wardrobeBtn.textContent="DOLAP";
wardrobeBtn.className="ui-btn";
wardrobeBtn.style.top="90px";
wardrobeBtn.style.right="10px";
document.body.appendChild(wardrobeBtn);

wardrobeBtn.onclick=openWardrobe;
/* ===============================
   ACHIEVEMENTS
================================= */

const achievements = {
  kill10:false,
  reach20:false
};

function checkAchievements(){
  if(player.level>=20 && !achievements.reach20){
    achievements.reach20=true;
    rewardCoins(500);
    alert("Achievement: Level 20!");
  }

  if(player.xp>=200 && !achievements.kill10){
    achievements.kill10=true;
    rewardCoins(200);
    alert("Achievement: XP 200!");
  }
}
/* ===============================
   DAILY REWARD
================================= */

function dailyReward(){
  const last = localStorage.getItem("daily");
  const now = Date.now();

  if(!last || now-last > 86400000){
    player.coins += 300;
    localStorage.setItem("daily",now);
    alert("Daily Reward: 300 coins!");
  }
}

dailyReward();
class SmartEnemy extends Enemy{
  constructor(x,y){
    super(x,y);
    this.angle=0;
  }

  update(dt){
    this.angle+=dt*4;
    const zig=Math.sin(this.angle)*60;

    const dx=player.x-this.x+zig;
    const dy=player.y-this.y;

    const d=Math.hypot(dx,dy);
    this.x+=(dx/d)*this.speed*dt;
    this.y+=(dy/d)*this.speed*dt;
  }
}

function spawnSmart(){
  enemies.push(new SmartEnemy(
    player.x+600,
    player.y
  ));
}

setInterval(()=>{
  if(player.level>=15) spawnSmart();
},10000);

setInterval(()=>{
  if(player.level>200){
    player.level=200;
  }
},3000);

</script>
</body>
</html>
