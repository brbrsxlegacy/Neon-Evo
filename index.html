<!DOCTYPE html>
<html lang="tr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>NEON RISE</title>

<style>
html, body {
  margin: 0;
  padding: 0;
  background: #05060a;
  overflow: hidden;
  touch-action: none;
  font-family: system-ui, sans-serif;
}

canvas {
  display: block;
  background: radial-gradient(circle at center, #0b1020, #02030a);
}

/* Mobil joystick */
#joystick {
  position: fixed;
  left: 20px;
  bottom: 20px;
  width: 140px;
  height: 140px;
  border-radius: 50%;
  background: rgba(0,255,255,0.08);
  border: 2px solid rgba(0,255,255,0.4);
}

#stick {
  position: absolute;
  left: 45px;
  top: 45px;
  width: 50px;
  height: 50px;
  border-radius: 50%;
  background: rgba(0,255,255,0.9);
}
</style>
</head>

<body>
<canvas id="game"></canvas>

<div id="joystick">
  <div id="stick"></div>
</div>

<script>
/* =========================
   CANVAS & GAME LOOP
========================= */
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
window.addEventListener("resize", resize);
resize();

let lastTime = 0;
function gameLoop(time) {
  const delta = (time - lastTime) / 1000;
  lastTime = time;
  update(delta);
  draw();
  requestAnimationFrame(gameLoop);
}
requestAnimationFrame(gameLoop);

/* =========================
   INPUT SYSTEM
========================= */
const keys = {};
window.addEventListener("keydown", e => keys[e.key] = true);
window.addEventListener("keyup", e => keys[e.key] = false);

/* Mobil joystick */
let joyX = 0, joyY = 0;
const joystick = document.getElementById("joystick");
const stick = document.getElementById("stick");
let dragging = false;

joystick.addEventListener("touchstart", e => dragging = true);
window.addEventListener("touchend", () => {
  dragging = false;
  joyX = joyY = 0;
  stick.style.left = "45px";
  stick.style.top = "45px";
});

window.addEventListener("touchmove", e => {
  if (!dragging) return;
  const rect = joystick.getBoundingClientRect();
  const touch = e.touches[0];
  let x = touch.clientX - rect.left - 70;
  let y = touch.clientY - rect.top - 70;
  const dist = Math.hypot(x, y);
  if (dist > 40) {
    x = x / dist * 40;
    y = y / dist * 40;
  }
  joyX = x / 40;
  joyY = y / 40;
  stick.style.left = 45 + x + "px";
  stick.style.top = 45 + y + "px";
});

/* =========================
   PLAYER
========================= */
const player = {
  x: 0,
  y: 0,
  size: 18,
  speed: 260
};

function update(dt) {
  let dx = 0, dy = 0;

  if (keys["w"] || keys["ArrowUp"]) dy -= 1;
  if (keys["s"] || keys["ArrowDown"]) dy += 1;
  if (keys["a"] || keys["ArrowLeft"]) dx -= 1;
  if (keys["d"] || keys["ArrowRight"]) dx += 1;

  dx += joyX;
  dy += joyY;

  const len = Math.hypot(dx, dy);
  if (len > 0) {
    dx /= len;
    dy /= len;
  }

  player.x += dx * player.speed * dt;
  player.y += dy * player.speed * dt;
}

/* =========================
   DRAW
========================= */
function draw() {
  ctx.clearRect(0,0,canvas.width,canvas.height);

  ctx.save();
  ctx.translate(canvas.width/2 - player.x, canvas.height/2 - player.y);

  // Grid
  ctx.strokeStyle = "rgba(0,255,255,0.05)";
  for (let x=-2000; x<2000; x+=60) {
    ctx.beginPath();
    ctx.moveTo(x, -2000);
    ctx.lineTo(x, 2000);
    ctx.stroke();
  }
  for (let y=-2000; y<2000; y+=60) {
    ctx.beginPath();
    ctx.moveTo(-2000, y);
    ctx.lineTo(2000, y);
    ctx.stroke();
  }

  // Player glow
  ctx.shadowBlur = 25;
  ctx.shadowColor = "#00ffff";
  ctx.fillStyle = "#00ffff";
  ctx.beginPath();
  ctx.arc(player.x, player.y, player.size, 0, Math.PI*2);
  ctx.fill();

  ctx.restore();
}

/* =========================
   ENEMY SYSTEM
========================= */

// Enemy listesi
const enemies = [];

// Enemy türleri
const ENEMY_TYPES = {
  MELEE: "melee",
  RANGED: "ranged"
};

// Enemy oluşturucu
function spawnEnemy(type = ENEMY_TYPES.MELEE) {
  const angle = Math.random() * Math.PI * 2;
  const dist = 600 + Math.random() * 400;

  enemies.push({
    type,
    x: player.x + Math.cos(angle) * dist,
    y: player.y + Math.sin(angle) * dist,
    size: 16,
    speed: type === ENEMY_TYPES.MELEE ? 140 : 90,
    cooldown: 0
  });
}

// Spawn aralığı
let enemySpawnTimer = 0;

// Update içine ENTEGRE
const _oldUpdate = update;
update = function(dt) {
  _oldUpdate(dt);

  enemySpawnTimer -= dt;
  if (enemySpawnTimer <= 0) {
    spawnEnemy(Math.random() < 0.5 ? ENEMY_TYPES.MELEE : ENEMY_TYPES.RANGED);
    enemySpawnTimer = 1.5;
  }

  enemies.forEach(e => {
    const dx = player.x - e.x;
    const dy = player.y - e.y;
    const dist = Math.hypot(dx, dy) || 1;

    if (e.type === ENEMY_TYPES.MELEE) {
      // Yakın dövüş: direkt takip
      e.x += (dx / dist) * e.speed * dt;
      e.y += (dy / dist) * e.speed * dt;
    } else {
      // Uzak menzil: mesafe korur
      if (dist > 220) {
        e.x += (dx / dist) * e.speed * dt;
        e.y += (dy / dist) * e.speed * dt;
      }
    }
  });
};

// Draw içine ENTEGRE
const _oldDraw = draw;
draw = function() {
  _oldDraw();

  ctx.save();
  ctx.translate(canvas.width/2 - player.x, canvas.height/2 - player.y);

  enemies.forEach(e => {
    ctx.shadowBlur = 20;
    ctx.shadowColor = e.type === ENEMY_TYPES.MELEE ? "#ff3355" : "#ffaa00";
    ctx.fillStyle = e.type === ENEMY_TYPES.MELEE ? "#ff3355" : "#ffaa00";

    ctx.beginPath();
    ctx.arc(e.x, e.y, e.size, 0, Math.PI * 2);
    ctx.fill();
  });

  ctx.restore();
};
/* =========================
   HEALTH & COLLISION SYSTEM
========================= */

// Oyuncu can sistemi
player.maxHealth = 100;
player.health = 100;
player.invuln = 0; // hasar sonrası kısa dokunulmazlık

// Basit çarpışma kontrolü (daire-daire)
function circleHit(ax, ay, ar, bx, by, br) {
  const dx = ax - bx;
  const dy = ay - by;
  return Math.hypot(dx, dy) < ar + br;
}

// Update'e entegre
const _update2 = update;
update = function(dt) {
  _update2(dt);

  // Dokunulmazlık süresi
  if (player.invuln > 0) player.invuln -= dt;

  // Düşman-oyuncu çarpışması
  enemies.forEach(e => {
    if (circleHit(player.x, player.y, player.size, e.x, e.y, e.size)) {
      if (player.invuln <= 0) {
        player.health -= e.type === ENEMY_TYPES.MELEE ? 10 : 6;
        player.invuln = 0.6;

        // küçük geri itme
        const dx = player.x - e.x;
        const dy = player.y - e.y;
        const d = Math.hypot(dx, dy) || 1;
        player.x += (dx / d) * 18;
        player.y += (dy / d) * 18;

        // Ölüm kontrolü
        if (player.health <= 0) {
          player.health = player.maxHealth;
          player.x = 0;
          player.y = 0;
          enemies.length = 0; // sahneyi temizle
        }
      }
    }
  });
};

// Draw'e HUD ekle
const _draw2 = draw;
draw = function() {
  _draw2();

  // HUD (ekran sabit)
  const pad = 16;
  const w = 220, h = 14;
  const ratio = Math.max(0, player.health / player.maxHealth);

  ctx.save();
  ctx.globalAlpha = 0.9;
  ctx.fillStyle = "rgba(255,255,255,0.15)";
  ctx.fillRect(pad, pad, w, h);

  ctx.shadowBlur = 10;
  ctx.shadowColor = "#00ff99";
  ctx.fillStyle = "#00ff99";
  ctx.fillRect(pad, pad, w * ratio, h);
  ctx.restore();
};
/* =========================
   XP & LEVEL SYSTEM
========================= */

// Oyuncu seviye verileri
player.level = 1;
player.xp = 0;
player.xpToNext = 100;

// Aura (geçici otomatik hasar)
player.auraRadius = 34;
player.auraDps = 30; // saniyede hasar

// Düşmanlara can ekle (mevcut olanlara da uygula)
function initEnemyHealth(e) {
  if (e.maxHealth == null) {
    e.maxHealth = e.type === ENEMY_TYPES.MELEE ? 40 : 30;
    e.health = e.maxHealth;
  }
}

// Level atlama
function levelUp() {
  player.level++;
  player.xp = 0;
  player.xpToNext = Math.floor(player.xpToNext * 1.35);

  // küçük güçlenme
  player.speed += 20;
  player.maxHealth += 10;
  player.health = player.maxHealth;

  // aura biraz büyür
  player.auraRadius += 3;
  player.auraDps += 5;

  // görsel minik patlama
  screenShake.time = 0.25;
}

// Screen shake altyapısı (hafif)
const screenShake = { time: 0, strength: 6 };

// Update’e entegre
const _update3 = update;
update = function(dt) {
  _update3(dt);

  // Screen shake süresi
  if (screenShake.time > 0) screenShake.time -= dt;

  // Düşmanlara aura hasarı
  for (let i = enemies.length - 1; i >= 0; i--) {
    const e = enemies[i];
    initEnemyHealth(e);

    const dx = player.x - e.x;
    const dy = player.y - e.y;
    const dist = Math.hypot(dx, dy);

    if (dist < player.auraRadius) {
      e.health -= player.auraDps * dt;

      if (e.health <= 0) {
        // XP kazan
        player.xp += e.type === ENEMY_TYPES.MELEE ? 20 : 15;
        enemies.splice(i, 1);

        // küçük sarsıntı
        screenShake.time = 0.12;

        if (player.xp >= player.xpToNext) {
          levelUp();
        }
      }
    }
  }
};

// Draw’e XP HUD + aura görseli
const _draw3 = draw;
draw = function() {
  // screen shake uygula
  let sx = 0, sy = 0;
  if (screenShake.time > 0) {
    sx = (Math.random() - 0.5) * screenShake.strength;
    sy = (Math.random() - 0.5) * screenShake.strength;
  }
  ctx.save();
  ctx.translate(sx, sy);
  _draw3();
  ctx.restore();

  // Aura görseli
  ctx.save();
  ctx.translate(canvas.width/2, canvas.height/2);
  ctx.globalAlpha = 0.15;
  ctx.strokeStyle = "#00ffff";
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.arc(0, 0, player.auraRadius, 0, Math.PI * 2);
  ctx.stroke();
  ctx.restore();

  // XP bar
  const pad = 16;
  const w = 220, h = 10;
  const ratio = Math.min(1, player.xp / player.xpToNext);

  ctx.save();
  ctx.globalAlpha = 0.9;
  ctx.fillStyle = "rgba(255,255,255,0.15)";
  ctx.fillRect(pad, pad + 22, w, h);

  ctx.shadowBlur = 10;
  ctx.shadowColor = "#6cf";
  ctx.fillStyle = "#6cf";
  ctx.fillRect(pad, pad + 22, w * ratio, h);

  // Level yazısı
  ctx.fillStyle = "#eaf2ff";
  ctx.font = "12px system-ui";
  ctx.fillText("LV " + player.level, pad + w + 10, pad + 32);
  ctx.restore();
};
/* =========================
   DRAW PIPELINE FIX
   (BLACK SCREEN HOTFIX)
========================= */

// Draw zincirini güvenli hale al
let __safeDraw = draw;

draw = function () {
  ctx.setTransform(1, 0, 0, 1, 0, 0); // reset transform
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // screen shake varsa uygula
  let sx = 0, sy = 0;
  if (typeof screenShake !== "undefined" && screenShake.time > 0) {
    sx = (Math.random() - 0.5) * screenShake.strength;
    sy = (Math.random() - 0.5) * screenShake.strength;
  }

  ctx.save();
  ctx.translate(sx, sy);
  __safeDraw();
  ctx.restore();
};
/* =========================
   ATTACK SYSTEM (MELEE + RANGED)
========================= */

// ---- INPUT (klavye + mobil) ----
const attackInput = {
  melee: false,
  ranged: false
};

// Klavye
window.addEventListener("keydown", e => {
  if (e.code === "Space") attackInput.melee = true;
  if (e.key === "f" || e.key === "F") attackInput.ranged = true;
});
window.addEventListener("keyup", e => {
  if (e.code === "Space") attackInput.melee = false;
  if (e.key === "f" || e.key === "F") attackInput.ranged = false;
});

// Mobil butonlar
const btnWrap = document.createElement("div");
btnWrap.style.cssText = `
  position:fixed; right:20px; bottom:20px; display:flex; gap:12px; z-index:9;
`;
document.body.appendChild(btnWrap);

function mkBtn(txt){
  const b = document.createElement("button");
  b.textContent = txt;
  b.style.cssText = `
    width:64px;height:64px;border-radius:50%;
    background:rgba(0,255,255,.15); color:#eaf2ff;
    border:2px solid rgba(0,255,255,.6); font-size:12px;
  `;
  btnWrap.appendChild(b);
  return b;
}
const meleeBtn = mkBtn("MELEE");
const rangedBtn = mkBtn("SHOT");

meleeBtn.addEventListener("touchstart", ()=>attackInput.melee=true);
meleeBtn.addEventListener("touchend", ()=>attackInput.melee=false);
rangedBtn.addEventListener("touchstart", ()=>attackInput.ranged=true);
rangedBtn.addEventListener("touchend", ()=>attackInput.ranged=false);

// ---- MELEE ----
player.melee = {
  range: 42,
  damage: 18,
  cooldown: 0,
  cdTime: 0.35
};

// ---- PROJECTILES ----
const bullets = [];
player.ranged = {
  speed: 520,
  damage: 14,
  cooldown: 0,
  cdTime: 0.25
};

function shootBullet(){
  // hedef: en yakın düşman yönü, yoksa ileri
  let tx = 1, ty = 0, best = Infinity;
  enemies.forEach(e=>{
    const dx = e.x - player.x;
    const dy = e.y - player.y;
    const d = Math.hypot(dx,dy);
    if (d < best){ best = d; tx = dx/d; ty = dy/d; }
  });
  bullets.push({
    x: player.x, y: player.y,
    vx: tx * player.ranged.speed,
    vy: ty * player.ranged.speed,
    r: 4
  });
}

// ---- UPDATE ENTEGRASYONU ----
const _update4 = update;
update = function(dt){
  _update4(dt);

  // cooldownlar
  if (player.melee.cooldown > 0) player.melee.cooldown -= dt;
  if (player.ranged.cooldown > 0) player.ranged.cooldown -= dt;

  // MELEE saldırı
  if (attackInput.melee && player.melee.cooldown <= 0){
    player.melee.cooldown = player.melee.cdTime;
    enemies.forEach(e=>{
      initEnemyHealth(e);
      const d = Math.hypot(e.x - player.x, e.y - player.y);
      if (d <= player.melee.range){
        e.health -= player.melee.damage;
        screenShake.time = 0.1;
      }
    });
  }

  // RANGED saldırı
  if (attackInput.ranged && player.ranged.cooldown <= 0){
    player.ranged.cooldown = player.ranged.cdTime;
    shootBullet();
  }

  // Bullet update + çarpışma
  for (let i = bullets.length-1; i>=0; i--){
    const b = bullets[i];
    b.x += b.vx * dt;
    b.y += b.vy * dt;

    // menzil dışı
    if (Math.hypot(b.x-player.x, b.y-player.y) > 900){
      bullets.splice(i,1); continue;
    }

    // düşman çarpışması
    for (let j = enemies.length-1; j>=0; j--){
      const e = enemies[j];
      initEnemyHealth(e);
      if (circleHit(b.x,b.y,b.r, e.x,e.y,e.size)){
        e.health -= player.ranged.damage;
        bullets.splice(i,1);
        screenShake.time = 0.08;
        if (e.health <= 0){
          player.xp += e.type === ENEMY_TYPES.MELEE ? 20 : 15;
          enemies.splice(j,1);
          if (player.xp >= player.xpToNext) levelUp();
        }
        break;
      }
    }
  }
};

// ---- DRAW ENTEGRASYONU ----
const _draw4 = draw;
draw = function(){
  _draw4();

  ctx.save();
  ctx.translate(canvas.width/2 - player.x, canvas.height/2 - player.y);

  // melee alanı
  if (player.melee.cooldown > player.melee.cdTime - 0.08){
    ctx.globalAlpha = 0.2;
    ctx.strokeStyle = "#00ffff";
    ctx.beginPath();
    ctx.arc(player.x, player.y, player.melee.range, 0, Math.PI*2);
    ctx.stroke();
  }

  // mermiler
  ctx.globalAlpha = 1;
  ctx.fillStyle = "#6cf";
  bullets.forEach(b=>{
    ctx.beginPath();
    ctx.arc(b.x,b.y,b.r,0,Math.PI*2);
    ctx.fill();
  });

  ctx.restore();
};
/* =========================
   VISUAL EFFECTS & POLISH
========================= */

// ---- PARTICLES ----
const particles = [];

function spawnParticles(x, y, color="#00ffff", count=10){
  for (let i=0;i<count;i++){
    particles.push({
      x, y,
      vx: (Math.random()-0.5)*260,
      vy: (Math.random()-0.5)*260,
      life: 0.4 + Math.random()*0.3,
      r: 2 + Math.random()*2,
      color
    });
  }
}

// ---- HIT FLASH ----
function hitFlash(e){
  e._flash = 0.1;
}

// ---- UPDATE ENTEGRASYONU ----
const _update5 = update;
update = function(dt){
  _update5(dt);

  // Particle update
  for (let i = particles.length-1; i>=0; i--){
    const p = particles[i];
    p.life -= dt;
    p.x += p.vx * dt;
    p.y += p.vy * dt;
    p.vx *= 0.96;
    p.vy *= 0.96;
    if (p.life <= 0) particles.splice(i,1);
  }

  // Enemy flash timer
  enemies.forEach(e=>{
    if (e._flash > 0) e._flash -= dt;
  });
};

// ---- DÜŞMAN ÖLÜMÜNE PARTİKÜL BAĞLA ----
const _killXP = levelUp;
levelUp = function(){
  spawnParticles(player.x, player.y, "#6cf", 18);
  _killXP();
};

// Mermi ve melee vuruşlarında efekt
const _shootBulletFx = shootBullet;
shootBullet = function(){
  _shootBulletFx();
  spawnParticles(player.x, player.y, "#6cf", 6);
};

// ---- DRAW ENTEGRASYONU ----
const _draw5 = draw;
draw = function(){
  _draw5();

  ctx.save();
  ctx.translate(canvas.width/2 - player.x, canvas.height/2 - player.y);

  // Particles
  particles.forEach(p=>{
    ctx.globalAlpha = Math.max(0, p.life);
    ctx.fillStyle = p.color;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.r, 0, Math.PI*2);
    ctx.fill();
  });

  ctx.restore();
};

</script>
</body>
</html>
