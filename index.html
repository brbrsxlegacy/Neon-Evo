<!DOCTYPE html>
<html lang="tr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<title>NEON OBLIVION ONLINE</title>
<style>
html,body{
  margin:0;padding:0;overflow:hidden;
  background:#05070f;font-family:system-ui;
}
canvas{display:block}
#hud{
  position:fixed;left:10px;top:10px;
  color:#0ff;font-size:12px;
}
.panel{
  position:fixed;bottom:10px;left:50%;
  transform:translateX(-50%);
  background:#000;border:1px solid #0ff;
  padding:8px;display:grid;
  grid-template-columns:repeat(5,60px);
  gap:4px;
}
.slot{
  width:60px;height:60px;
  background:#111;border:1px solid #0ff;
  font-size:10px;color:#fff;
  display:flex;align-items:center;justify-content:center;
}
</style>
</head>
<body>
<canvas id="game"></canvas>
<div id="hud"></div>
<div id="inventory" class="panel"></div>

<script type="module">

/* ================= FIREBASE ================= */

import { initializeApp } from 
"https://www.gstatic.com/firebasejs/10.12.0/firebase-app.js";

import { getDatabase, ref, set, onValue, onDisconnect, runTransaction }
from "https://www.gstatic.com/firebasejs/10.12.0/firebase-database.js";

const firebaseConfig = {
  apiKey: "AIzaSyABqkhpL1SMRzRJ9GQLjjZE2IryqpAvMPw",
  authDomain: "pixelroom-ae218.firebaseapp.com",
  databaseURL: "https://pixelroom-ae218-default-rtdb.europe-west1.firebasedatabase.app",
  projectId: "pixelroom-ae218",
  storageBucket: "pixelroom-ae218.firebasestorage.app",
  messagingSenderId: "720297722320",
  appId: "1:720297722320:web:c815edae99d1efa7ff39d5"
};

const app = initializeApp(firebaseConfig);
const db = getDatabase(app);

/* ================= CANVAS ================= */

const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

function resize(){
  canvas.width = innerWidth;
  canvas.height = innerHeight;
}
resize();
addEventListener("resize",resize);

/* ================= GAME LOOP ================= */

let last=0,dt=0;

function loop(t){
  dt=(t-last)/1000;
  last=t;

  Systems.update(dt);
  Systems.draw();

  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

/* ================= INPUT ================= */

const Input={keys:{},mouse:{x:0,y:0}};
addEventListener("keydown",e=>Input.keys[e.key]=true);
addEventListener("keyup",e=>Input.keys[e.key]=false);
addEventListener("mousemove",e=>{
  Input.mouse.x=e.clientX;
  Input.mouse.y=e.clientY;
});

/* ================= ECS ================= */

const ECS={
  entities:[],
  c:{
    pos:new Map(),
    vel:new Map(),
    rend:new Map(),
    hp:new Map(),
    player:new Map(),
    enemy:new Map(),
    bullet:new Map()
  },
  create(){
    const id=crypto.randomUUID();
    this.entities.push(id);
    return id;
  },
  remove(id){
    this.entities=this.entities.filter(e=>e!==id);
    for(const k in this.c) this.c[k].delete(id);
  }
};

/* ================= PLAYER ================= */

const Player={id:null,level:1,xp:0,xpNext:100};

function createPlayer(){
  const id=ECS.create();
  ECS.c.pos.set(id,{x:0,y:0});
  ECS.c.vel.set(id,{x:0,y:0});
  ECS.c.rend.set(id,{c:"#0ff",s:20});
  ECS.c.hp.set(id,{v:100,max:100});
  ECS.c.player.set(id,{});
  Player.id=id;
}
createPlayer();

/* ================= ENEMIES ================= */

function spawnEnemy(){
  const id=ECS.create();
  const p=ECS.c.pos.get(Player.id);
  ECS.c.pos.set(id,{
    x:p.x+Math.random()*600-300,
    y:p.y+Math.random()*600-300
  });
  ECS.c.rend.set(id,{c:"#f33",s:18});
  ECS.c.hp.set(id,{v:60,max:60});
  ECS.c.enemy.set(id,{});
}
setInterval(spawnEnemy,2000);

/* ================= SHOOT ================= */

addEventListener("click",()=>{
  const id=ECS.create();
  const p=ECS.c.pos.get(Player.id);

  const angle=Math.atan2(
    Input.mouse.y-canvas.height/2,
    Input.mouse.x-canvas.width/2
  );

  ECS.c.pos.set(id,{x:p.x,y:p.y});
  ECS.c.vel.set(id,{
    x:Math.cos(angle)*400,
    y:Math.sin(angle)*400
  });
  ECS.c.rend.set(id,{c:"#6cf",s:6});
  ECS.c.bullet.set(id,{});
});

/* ================= INVENTORY ================= */

const Inventory={items:Array(20).fill(null)};

function initInventory(){
  const inv=document.getElementById("inventory");
  Inventory.items.forEach((_,i)=>{
    const slot=document.createElement("div");
    slot.className="slot";
    slot.dataset.i=i;
    inv.appendChild(slot);
  });
}
initInventory();

function renderInventory(){
  document.querySelectorAll(".slot").forEach((s,i)=>{
    const item=Inventory.items[i];
    s.textContent=item?item.name:"";
  });
}

/* ================= LOOT ================= */

function generateLoot(){
  const rar=Math.random();
  let r="COMMON";
  if(r>0.9) r="LEGENDARY";
  else if(r>0.7) r="EPIC";
  else if(r>0.5) r="RARE";
  return {name:r+" Blade",rarity:r};
}

/* ================= SKILL TREE ================= */

const Skills={
  points:0,
  dmg:0,
  speed:0,
  vit:0
};

function levelUp(){
  Player.level++;
  Player.xp=0;
  Player.xpNext=Math.floor(Player.xpNext*1.3);
  Skills.points++;
}

/* ================= SYSTEMS ================= */

const Systems={

  update(dt){
    this.control();
    this.movement(dt);
    this.combat(dt);
    this.enemyAI(dt);
    this.collision();
    this.network();
    this.hud();
  },

  draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.save();
    const p=ECS.c.pos.get(Player.id);
    ctx.translate(canvas.width/2-p.x,canvas.height/2-p.y);

    for(const [id,pos] of ECS.c.pos){
      const r=ECS.c.rend.get(id);
      ctx.fillStyle=r.c;
      ctx.beginPath();
      ctx.arc(pos.x,pos.y,r.s,0,Math.PI*2);
      ctx.fill();
    }
    ctx.restore();
  },

  control(){
    const vel=ECS.c.vel.get(Player.id);
    vel.x=0; vel.y=0;
    const speed=200+Skills.speed*20;
    if(Input.keys["w"]) vel.y=-speed;
    if(Input.keys["s"]) vel.y=speed;
    if(Input.keys["a"]) vel.x=-speed;
    if(Input.keys["d"]) vel.x=speed;
  },

  movement(dt){
    for(const [id,pos] of ECS.c.pos){
      const vel=ECS.c.vel.get(id);
      if(!vel) continue;
      pos.x+=vel.x*dt;
      pos.y+=vel.y*dt;
    }
  },

  combat(dt){
    for(const [id,_] of ECS.c.bullet){
      const pos=ECS.c.pos.get(id);
      const vel=ECS.c.vel.get(id);
      pos.x+=vel.x*dt;
      pos.y+=vel.y*dt;

      for(const [eid,_] of ECS.c.enemy){
        const epos=ECS.c.pos.get(eid);
        if(Math.hypot(pos.x-epos.x,pos.y-epos.y)<20){
          const hp=ECS.c.hp.get(eid);
          hp.v-=20+Skills.dmg*5;
          ECS.remove(id);
        }
      }
    }
  },

  enemyAI(dt){
    for(const [id,_] of ECS.c.enemy){
      const pos=ECS.c.pos.get(id);
      const p=ECS.c.pos.get(Player.id);
      const dx=p.x-pos.x;
      const dy=p.y-pos.y;
      const d=Math.hypot(dx,dy)||1;
      pos.x+=(dx/d)*80*dt;
      pos.y+=(dy/d)*80*dt;
    }
  },

  collision(){
    for(const [id,h] of ECS.c.hp){
      if(h.v<=0){
        if(ECS.c.enemy.has(id)){
          Player.xp+=20;
          if(Player.xp>=Player.xpNext) levelUp();
          Inventory.items[
            Inventory.items.findIndex(x=>x==null)
          ]=generateLoot();
          renderInventory();
        }
        ECS.remove(id);
      }
    }
  },

  hud(){
    const hp=ECS.c.hp.get(Player.id);
    document.getElementById("hud").innerHTML=
      "HP:"+Math.floor(hp.v)+
      "<br>LV:"+Player.level+
      "<br>XP:"+Player.xp+"/"+Player.xpNext+
      "<br>SP:"+Skills.points;
  },

  network(){
    if(!Network.room) return;
    const pos=ECS.c.pos.get(Player.id);
    set(Network.myRef,{x:pos.x,y:pos.y});
  }
};

/* ================= NETWORK ================= */

const Network={room:null,myRef:null};

function createRoom(){
  const r="room_"+Math.random().toString(36).substr(2,5);
  Network.room=r;
  Network.myRef=ref(db,"rooms/"+r+"/players/"+crypto.randomUUID());
  set(Network.myRef,{x:0,y:0});
  onDisconnect(Network.myRef).remove();
}
createRoom();

/* ================= MATCH TIMER ================= */

let match=300;
setInterval(()=>{
  match--;
  if(match<=0) alert("Match Over");
},1000);

/* ================= BATTLE PASS ================= */

const BP={xp:0,tier:1};
function gainBP(v){
  BP.xp+=v;
  if(BP.xp>100){BP.tier++;BP.xp=0;}
}

/* ================= ANTI CHEAT ================= */

setInterval(()=>{
  const hp=ECS.c.hp.get(Player.id);
  if(hp.v>200) hp.v=200;
},2000);
/* ======================================================
   GRID + A* PATHFINDING
====================================================== */

const Grid = {
  size:60,
  cell:80,
  map:[],
  generate(){
    this.map=[];
    for(let y=0;y<this.size;y++){
      const row=[];
      for(let x=0;x<this.size;x++){
        row.push(Math.random()>0.15?0:1);
      }
      this.map.push(row);
    }
  },
  walkable(x,y){
    if(x<0||y<0||x>=this.size||y>=this.size) return false;
    return this.map[y][x]===0;
  }
};
Grid.generate();

function heuristic(a,b){
  return Math.abs(a.x-b.x)+Math.abs(a.y-b.y);
}

function astar(start,end){
  const open=[{...start,g:0,f:0,parent:null}];
  const closed=new Set();

  while(open.length){
    open.sort((a,b)=>a.f-b.f);
    const current=open.shift();
    const key=current.x+","+current.y;
    if(current.x===end.x&&current.y===end.y){
      const path=[];
      let n=current;
      while(n){path.push(n);n=n.parent;}
      return path.reverse();
    }
    closed.add(key);

    const dirs=[
      {x:1,y:0},{x:-1,y:0},
      {x:0,y:1},{x:0,y:-1}
    ];

    for(const d of dirs){
      const nx=current.x+d.x;
      const ny=current.y+d.y;
      if(!Grid.walkable(nx,ny)) continue;
      const nKey=nx+","+ny;
      if(closed.has(nKey)) continue;
      const g=current.g+1;
      const h=heuristic({x:nx,y:ny},end);
      open.push({
        x:nx,y:ny,g,f:g+h,parent:current
      });
    }
  }
  return [];
}

/* ======================================================
   BOSS 3 PHASE SYSTEM
====================================================== */

function spawnBoss(){
  const id=ECS.create();
  const p=ECS.c.pos.get(Player.id);
  ECS.c.pos.set(id,{x:p.x+400,y:p.y});
  ECS.c.rend.set(id,{c:"#f0f",s:40});
  ECS.c.hp.set(id,{v:500,max:500});
  ECS.c.enemy.set(id,{boss:true,phase:1});
}

function bossAI(dt){
  for(const [id,e] of ECS.c.enemy){
    if(!e.boss) continue;
    const hp=ECS.c.hp.get(id);
    const pos=ECS.c.pos.get(id);
    const p=ECS.c.pos.get(Player.id);

    if(hp.v<350) e.phase=2;
    if(hp.v<150) e.phase=3;

    const dx=p.x-pos.x;
    const dy=p.y-pos.y;

    if(e.phase===1){
      pos.x+=dx*0.01;
      pos.y+=dy*0.01;
    }
    if(e.phase===2){
      pos.x+=dx*0.02;
      pos.y+=dy*0.02;
      if(Math.random()<0.02) spawnEnemy();
    }
    if(e.phase===3){
      pos.x+=dx*0.03;
      pos.y+=dy*0.03;
    }
  }
}
setInterval(()=>bossAI(dt),50);
setInterval(spawnBoss,60000);

/* ======================================================
   PARTY SYSTEM
====================================================== */

const Party={
  members:[Player.id],
  invite(id){
    if(this.members.length<4){
      this.members.push(id);
    }
  }
};

/* ======================================================
   CLAN SYSTEM (FIREBASE)
====================================================== */

function createClan(name){
  set(ref(db,"clans/"+name+"/members/"+Player.id),true);
}

function joinClan(name){
  set(ref(db,"clans/"+name+"/members/"+Player.id),true);
}

/* ======================================================
   SECURE PvP
====================================================== */

function securePvP(targetId){
  const targetRef=ref(
    db,
    "rooms/"+Network.room+"/players/"+targetId+"/hp"
  );

  runTransaction(targetRef,(hp)=>{
    if(hp==null) return 100;
    return hp-15;
  });
}

/* ======================================================
   MARKET SYSTEM
====================================================== */

const Market={
  list:[],
  sell(item){
    this.list.push(item);
  },
  buy(index){
    const item=this.list[index];
    if(item){
      Inventory.items[
        Inventory.items.findIndex(x=>x==null)
      ]=item;
      this.list.splice(index,1);
      renderInventory();
    }
  }
};

/* ======================================================
   ABILITIES + COOLDOWN
====================================================== */

const Abilities={
  fireball:{cd:3,last:0},
  dash:{cd:5,last:0},

  use(name){
    const a=this[name];
    const now=performance.now()/1000;
    if(now-a.last<a.cd) return;
    a.last=now;

    if(name==="fireball"){
      for(let i=0;i<10;i++){
        spawnEnemy();
      }
    }
    if(name==="dash"){
      const vel=ECS.c.vel.get(Player.id);
      vel.x*=3;
      vel.y*=3;
    }
  }
};

addEventListener("keydown",e=>{
  if(e.key==="1") Abilities.use("fireball");
  if(e.key==="2") Abilities.use("dash");
});

/* ======================================================
   FLOATING DAMAGE
====================================================== */

const Floating=[];

function spawnFloating(x,y,text){
  Floating.push({x,y,text,life:1});
}

function updateFloating(){
  for(let i=Floating.length-1;i>=0;i--){
    const f=Floating[i];
    f.y-=30*dt;
    f.life-=dt;
    if(f.life<=0) Floating.splice(i,1);
  }
}

function drawFloating(){
  Floating.forEach(f=>{
    ctx.globalAlpha=f.life;
    ctx.fillStyle="#ff0";
    ctx.fillText(f.text,f.x,f.y);
    ctx.globalAlpha=1;
  });
}
setInterval(updateFloating,16);

/* ======================================================
   WORLD EVENTS
====================================================== */

function worldEvent(){
  alert("WORLD EVENT STARTED!");
  for(let i=0;i<20;i++){
    spawnEnemy();
  }
}
setInterval(worldEvent,120000);

/* ======================================================
   SAVE / LOAD
====================================================== */

function saveGame(){
  localStorage.setItem("save",
    JSON.stringify({
      level:Player.level,
      inventory:Inventory.items
    })
  );
}

function loadGame(){
  const data=JSON.parse(localStorage.getItem("save")||"{}");
  if(data.level) Player.level=data.level;
  if(data.inventory) Inventory.items=data.inventory;
  renderInventory();
}
loadGame();
setInterval(saveGame,15000);

</script>
</body>
</html>
